# 第 6 章 内核数据结构

<!--toc:start-->

- [第 6 章 内核数据结构](#第-6-章-内核数据结构)
  - [6.1 链表](#61-链表)
- [6.1.1 单向链表和双向链表](#611-单向链表和双向链表)
  - [6.1.2 环形链表](#612-环形链表)
  - [6.1.3 沿链表移动](#613-沿链表移动)
  - [6.1.4 Linux 内核中的实现](#614-linux-内核中的实现)
  - [6.1.5 操作链表](#615-操作链表)
  - [6.1.6 遍历链表](#616-遍历链表)
  - [6.2 队列](#62-队列)
  - [6.3 映射](#63-映射)
    - [6.3.1 初始化一个idr](#631-初始化一个idr)
    - [6.3.2 分配一个新的UID](#632-分配一个新的uid)
    - [6.3.3 查找 UID](#633-查找-uid)
    - [6.3.4 删除 UID](#634-删除-uid)
    - [6.3.5 撤销 idr](#635-撤销-idr)
  - [6.4 二叉树](#64-二叉树)
    - [6.4.1 二叉搜索树](#641-二叉搜索树)
    - [6.4.2 自平衡二叉树](#642-自平衡二叉树)
      - [1. 红黑树 [^1]](#1-红黑树-1)
      - [2. rbtree](#2-rbtree)
  - [6.5 数据结构以及选择](#65-数据结构以及选择)
  - [6.6 算法复杂度](#66-算法复杂度) - [6.6.4 时间复杂度](#664-时间复杂度)
  <!--toc:end-->

## 6.1 链表

# 6.1.1 单向链表和双向链表

单向链表仅有后指针，双向链表多一个前指针

`<linux/list.h>`:

```c
/*
 * Simple doubly linked list implementation.
 *
 * Some of the internal functions ("__xxx") are useful when
 * manipulating whole lists rather than single entries, as
 * sometimes we already know the next/prev entries and we can
 * generate better code by using them directly rather than
 * using the generic single-entry routines.
 */

struct list_head {
 struct list_head *next, *prev;
};

#define LIST_HEAD_INIT(name) { &(name), &(name) }

#define LIST_HEAD(name)                                 \
 struct list_head name = LIST_HEAD_INIT(name)

```

### 6.1.2 环形链表

首尾相连，尾节点的后指针指向头节点

### 6.1.3 沿链表移动

只能是线性移动

### 6.1.4 Linux 内核中的实现

```c
struct fox {
        unsigned long tail_length;
        unsigned long weight;
        bool is_fantastic;
};
```

Linux 内核实现不是将数据结构塞入链表，而是将链表塞入数据结构

1. 链表数据结构

   ```c
   struct fox {
           unsigned long tail_length;
           unsigned long weight;
           bool is_fantastic;
           struct list_head list;
   };
   ```

   使用`container_of()`宏可以从链表指针找到父结构包含的任何变量

   ```c
   /**
    * container_of - cast a member of a structure out to the containing structure
    * @ptr: the pointer to the member.
    * @type: the type of the container struct this is embedded in.
    * @member: the name of the member within the struct.
    *
    */
   #define container_of(ptr, type, member) ({   \
    const typeof( ((type *)0)->member ) *__mptr = (ptr); \
    (type *)( (char *)__mptr - offsetof(type,member) );})

   /**
    * list_entry - get the struct for this entry
    * @ptr: the &struct list_head pointer.
    * @type: the type of the struct this is embedded in.
    * @member: the name of the list_struct within the struct.
    */
   #define list_entry(ptr, type, member)           \
    container_of(ptr, type, member)
   ```

2. 定义一个链表

   ```c
   struct fox {
           unsigned long tail_length;
           unsigned long weight;
           bool is_fantastic;
           struct list_head list;
   };
   ```

   初始化:

   ```c
   struct fox *red_fox = NULL;
   red_fox = kmalloc(sizeof(*red_fox), GFP_KERNEL);
   red_fox->tail_length = 40;
   red_fox->weight = 6;
   red_fox->is_fantastic = false;

   INIT_LIST_HEAD(&red_fox->list);
   ```

   如果在编译期间静态创建,则需要直接给出链表的直接引用

   ```c
   struct fox red_fox = {
   .tail_length = 40,
   .weight = 6,

   .list = LIST_HEAD_INIT(red_fox.list);
   };
   ```

3. 链表头

   ```c
   static LIST_HEAD(fox_list);
   ```

### 6.1.5 操作链表

阅读 `<linux/list.h>`　源码

1. 向链表中添加一个节点

   ```c
   list_add(&f->list, &fox_list);
   ```

### 6.1.6 遍历链表

1. 基本方法

   ```c
   struct list_head *p;
   struct fox *f;

   list_for_each(p, &fox_list) {
   f = list_entry(p, struct fox, list);
   }
   ```

2. 可用的方法

   intify 实例,　内核文件系统的更新通知机制:

   ```c
   struct inotify_watch {
   struct list_head        h_list; /* entry in inotify_handle's list */
   struct list_head        i_list; /* entry in inode's list */
   atomic_t                count;  /* reference count */
   struct inotify_handle  *ih;     /* associated inotify handle */
   struct inode           *inode;  /* associated inode */
   __s32                   wd;     /* watch descriptor */
   __u32                   mask;   /* event mask for this watch */
   };

   /*
   * inotify_find_handle - find the watch associated with the given inode and
   * handle
   *
   * Callers must hold inode->inotify_mutex.
   */
   static struct inotify_watch *inode_find_handle(struct inode *inode,
               struct inotify_handle *ih)
   {
   struct inotify_watch *watch;

   list_for_each_entry(watch, &inode->inotify_watches, i_list)
   {
   if (watch->ih == ih)
   return watch;
   }

   return NULL;
   }
   ```

3. 反向遍历链表

   ```c
   list_for_each_entry_reverse(pos, head, member);
   ```

4. 遍历的同时删除

   inotify 实例:

   ```c
   list_for_each_entry_safe(pos, next, head, member);
   ```

   ```c
   /**
   * inotify_inode_is_dead - an inode has been deleted, cleanup any watches
   * @inode: inode that is about to be removed
   */
   void inotify_inode_is_dead(struct inode *inode)
   {
   struct inotify_watch *watch, *next;

   mutex_lock(&inode->inotify_mutex);
   list_for_each_entry_safe(watch, next, &inode->inotify_watches, i_list) {
   struct inotify_handle *ih = watch->ih;
   mutex_lock(&ih->mutex);
   inotify_remove_watch_locked(ih, watch);
   mutex_unlock(&ih->mutex);
   }
   mutex_unlock(&inode->inotify_mutex);
   }
   EXPORT_SYMBOL_GPL(inotify_inode_is_dead);
   ```

   > **`list_for_each_entry_safe`版本保证了在循环何中从链表删除数据，但是并发删除依然需要锁定**

5. 其他链表方法

   参见 `<linux/list.h>`

## 6.2 队列

阅读 `<linux/kfifo.h>`和`kernel/kfifo.c`

```c
struct kfifo {
 unsigned char *buffer; /* the buffer holding the data */
 unsigned int size; /* the size of the allocated buffer */
 unsigned int in; /* data is added at offset (in % size) */
 unsigned int out; /* data is extracted from off. (out % size) */
};
```

## 6.3 映射

- Add (key, value)

- Remove (key)

- value = Lookup (key)

键值对。无通用实现，`<linux/idr.h>`和`kernel/idr.c`　作为映射用户UID的实例。

### 6.3.1 初始化一个idr

```c
void idr_init(struct idr *idp);
```

范例:

```c
struct idr id_huh;
idr_init(&id_huh);
```

### 6.3.2 分配一个新的UID

1. 调整后备份树的大小 `idr_pre_get()`

   调整由idp指向的idr的大小。**成功时返回1，失败时返回0。**

   ```c
   /**
   * idr_pre_get - reserver resources for idr allocation
   * @idp: idr handle
   * @gfp_mask: memory allocation flags
   *
   * This function should be called prior to locking and calling the
   * idr_get_new* functions. It preallocates enough memory to satisfy
   * the worst possible allocation.
   *
   * If the system is REALLY out of memory this function returns 0,
   * otherwise 1.
   */
   int idr_pre_get(struct idr *idp, gfp_t gfp_mask)
   {
   while (idp->id_free_cnt < IDR_FREE_MAX) {
   struct idr_layer *new;
   new = kmem_cache_zalloc(idr_layer_cache, gfp_mask);
   if (new == NULL)
   return (0);
   move_to_free_list(idp, new);
   }
   return 1;
   }
   EXPORT_SYMBOL(idr_pre_get);
   ```

2. 获取新的UID，并将其加到idr的方法是`idr_get_new()`

   ```c
   /**
   * ida_get_new - allocate new ID
   * @ida: idr handle
   * @p_id: pointer to the allocated handle
   *
   * Allocate new ID.  It should be called with any required locks.
   *
   * If memory is required, it will return -EAGAIN, you should unlock
   * and go back to the idr_pre_get() call.  If the idr is full, it will
   * return -ENOSPC.
   *
   * @id returns a value in the range 0 ... 0x7fffffff.
   */
   int ida_get_new(struct ida *ida, int *p_id)
   {
   return ida_get_new_above(ida, 0, p_id);
   }
   EXPORT_SYMBOL(ida_get_new);

   /**
   * ida_get_new_above - allocate new ID above or equal to a start id
   * @ida: ida handle
   * @staring_id: id to start search at
   * @p_id: pointer to the allocated handle
   *
   * Allocate new ID above or equal to @ida.  It should be called with
   * any required locks.
   *
   * If memory is required, it will return -EAGAIN, you should unlock
   * and go back to the ida_pre_get() call.  If the ida is full, it will
   * return -ENOSPC.
   *
   * @p_id returns a value in the range @starting_id ... 0x7fffffff.
   */
   int ida_get_new_above(struct ida *ida, int starting_id, int *p_id);
   ```

   范例:

   ```c
   int id;

   do {
   if (!idr_pre_get(&idr_huh, GFP_KERNEL))
   return -ENOSPC;
   ret = idr_get_new(&idr_huh, ptr, &id);
   } while (ret == -EAGAIN);

   ```

### 6.3.3 查找 UID

```c
/**
 * idr_find - return pointer for given id
 * @idp: idr handle
 * @id: lookup key
 *
 * Return the pointer given the id it has been registered with.  A %NULL
 * return indicates that @id is not valid or you passed %NULL in
 * idr_get_new().
 *
 * This function can be called under rcu_read_lock(), given that the leaf
 * pointers lifetimes are correctly managed.
 */
void *idr_find(struct idr *idp, int id);
```

### 6.3.4 删除 UID

```c
/**
 * idr_remove - remove the given id and free it's slot
 * @idp: idr handle
 * @id: unique key
 */
void idr_remove(struct idr *idp, int id);
```

### 6.3.5 撤销 idr

只释放 idr 中未使用的内存，并不释放当前分配给 UID 使用的内存。

```c
/**
 * idr_destroy - release all cached layers within an idr tree
 * idp: idr handle
 */
void idr_destroy(struct idr *idp);
/**
 * idr_destroy - release all cached layers within an idr tree
 * idp: idr handle
 */
void idr_destroy(struct idr *idp);
```

调用 `idr_remove_all()` 可以删除所有的 UID

```c
/**
 * idr_remove_all - remove all ids from the given idr tree
 * @idp: idr handle
 *
 * idr_destroy() only frees up unused, cached idp_layers, but this
 * function will remove all id mappings and leave all idp_layers
 * unused.
 *
 * A typical clean-up sequence for objects stored in an idr tree, will
 * use idr_for_each() to free all objects, if necessay, then
 * idr_remove_all() to remove all ids, and idr_destroy() to free
 * up the cached idr_layers.
 */
void idr_remove_all(struct idr *idp);
```

## 6.4 二叉树

### 6.4.1 二叉搜索树

> - 根的左分支节点值都小于根节点值
> - 右分支节点值都大于根节点值
> - 所有的子树也都是二叉搜索树

### 6.4.2 自平衡二叉树

#### 1. 红黑树 [^1]

> 1. 所有的节点要么着红色，要么着黑色
> 1. 叶子节点都是黑色
> 1. 叶子节点不包含数据
> 1. 所有非叶子节点都有两个子节点
> 1. 如果一个节点是红色，则它的子节点都是黑色
> 1. 如果一个节点到其叶子节点的路径中，如果总是包含同样数据的黑色节点，则该路径相比其他路径是最短的。

#### 2. rbtree

代码实现见 `<linux/rbtree.h>`和`lib/rbtree.c`

在页高速缓存中搜索和插入文件区的示例代码:

```c
static inline struct page * rb_search_page_cache(struct inode * inode,
       unsigned long offset)
{
 struct rb_node * n = inode->i_rb_page_cache.rb_node;
 struct page * page;

 while (n)
 {
  page = rb_entry(n, struct page, rb_page_cache);

  if (offset < page->offset)
   n = n->rb_left;
  else if (offset > page->offset)
   n = n->rb_right;
  else
   return page;
 }
 return NULL;
}

static inline struct page * __rb_insert_page_cache(struct inode * inode,
         unsigned long offset,
         struct rb_node * node)
{
 struct rb_node ** p = &inode->i_rb_page_cache.rb_node;
 struct rb_node * parent = NULL;
 struct page * page;

 while (*p)
 {
  parent = *p;
  page = rb_entry(parent, struct page, rb_page_cache);

  if (offset < page->offset)
   p = &(*p)->rb_left;
  else if (offset > page->offset)
   p = &(*p)->rb_right;
  else
   return page;
 }

 rb_link_node(node, parent, p);

 return NULL;
}

static inline struct page * rb_insert_page_cache(struct inode * inode,
       unsigned long offset,
       struct rb_node * node)
{
 struct page * ret;
 if ((ret = __rb_insert_page_cache(inode, offset, node)))
  goto out;
 rb_insert_color(node, &inode->i_rb_page_cache);
 out:
 return ret;
}
```

## 6.5 数据结构以及选择

- 主要操作是遍历数据使用链表
- 代码符合生产者/消费者模式，使用队列
- 需要映射一个键值到一个对象，使用映射
- 需要存储大量数据，并且检索迅速，使用红黑树。

## 6.6 算法复杂度

### 6.6.4 时间复杂度

_表 6-1 时间复杂度表_

| $O(g(x))$ | 名称   |
| --------- | ------ |
| $1$       | 恒量   |
| $\log_n$  | 对数的 |
| $n$       | 线性的 |
| $n^2$     | 平方的 |
| $n^3$     | 立方的 |
| $2^n$     | 指数的 |
| $n!$      | 阶乘   |

[^1]: [平衡查找树](https://zefrain.github.io/docs/TOC/computer/Algorithms/Algorithms/ch03#33-%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91)
